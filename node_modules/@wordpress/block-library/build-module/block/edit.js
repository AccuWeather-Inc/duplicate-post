import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { createElement } from "@wordpress/element";

/**
 * WordPress dependencies
 */
import { useSelect, useDispatch } from '@wordpress/data';
import { useEntityBlockEditor } from '@wordpress/core-data';
import { useCallback } from '@wordpress/element';
import { Placeholder, Spinner, Disabled, ToolbarGroup, ToolbarButton } from '@wordpress/components';
import { __ } from '@wordpress/i18n';
import { BlockEditorProvider, WritingFlow, BlockList, BlockControls, useBlockProps } from '@wordpress/block-editor';
/**
 * Internal dependencies
 */

import ReusableBlockEditPanel from './edit-panel';
export default function ReusableBlockEdit(_ref) {
  var ref = _ref.attributes.ref,
      clientId = _ref.clientId,
      isSelected = _ref.isSelected;
  var recordArgs = ['postType', 'wp_block', ref];

  var _useSelect = useSelect(function (select) {
    var _select, _select2;

    return {
      reusableBlock: (_select = select('core')).getEditedEntityRecord.apply(_select, recordArgs),
      hasResolved: select('core').hasFinishedResolution('getEditedEntityRecord', recordArgs),
      isSaving: (_select2 = select('core')).isSavingEntityRecord.apply(_select2, recordArgs),
      canUserUpdate: select('core').canUser('update', 'blocks', ref),
      isEditing: select('core/reusable-blocks').__experimentalIsEditingReusableBlock(clientId),
      settings: select('core/block-editor').getSettings()
    };
  }, [ref, clientId]),
      reusableBlock = _useSelect.reusableBlock,
      hasResolved = _useSelect.hasResolved,
      isEditing = _useSelect.isEditing,
      isSaving = _useSelect.isSaving,
      canUserUpdate = _useSelect.canUserUpdate,
      settings = _useSelect.settings;

  var _useDispatch = useDispatch('core'),
      editEntityRecord = _useDispatch.editEntityRecord,
      saveEditedEntityRecord = _useDispatch.saveEditedEntityRecord;

  var _useDispatch2 = useDispatch('core/reusable-blocks'),
      __experimentalSetEditingReusableBlock = _useDispatch2.__experimentalSetEditingReusableBlock;

  var setIsEditing = useCallback(function (value) {
    __experimentalSetEditingReusableBlock(clientId, value);
  }, [clientId]);

  var _useDispatch3 = useDispatch('core/reusable-blocks'),
      convertBlockToStatic = _useDispatch3.__experimentalConvertBlockToStatic;

  var _useDispatch4 = useDispatch('core/notices'),
      createSuccessNotice = _useDispatch4.createSuccessNotice,
      createErrorNotice = _useDispatch4.createErrorNotice;

  var save = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return saveEditedEntityRecord.apply(void 0, recordArgs);

          case 3:
            createSuccessNotice(__('Block updated.'), {
              type: 'snackbar'
            });
            _context.next = 9;
            break;

          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            createErrorNotice(_context.t0.message, {
              type: 'snackbar'
            });

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 6]]);
  })), recordArgs);

  var _useEntityBlockEditor = useEntityBlockEditor('postType', 'wp_block', {
    id: ref
  }),
      _useEntityBlockEditor2 = _slicedToArray(_useEntityBlockEditor, 3),
      blocks = _useEntityBlockEditor2[0],
      onInput = _useEntityBlockEditor2[1],
      onChange = _useEntityBlockEditor2[2];

  var blockProps = useBlockProps();

  if (!hasResolved) {
    return createElement("div", blockProps, createElement(Placeholder, null, createElement(Spinner, null)));
  }

  if (!reusableBlock) {
    return createElement("div", blockProps, createElement(Placeholder, null, __('Block has been deleted or is unavailable.')));
  }

  var element = createElement(BlockEditorProvider, {
    value: blocks,
    onInput: onInput,
    onChange: onChange,
    settings: settings
  }, createElement(WritingFlow, null, createElement(BlockList, null)));

  if (!isEditing) {
    element = createElement(Disabled, null, element);
  }

  return createElement("div", blockProps, createElement(BlockControls, null, createElement(ToolbarGroup, null, createElement(ToolbarButton, {
    onClick: function onClick() {
      return convertBlockToStatic(clientId);
    }
  }, __('Convert to regular blocks')))), createElement("div", {
    className: "block-library-block__reusable-block-container"
  }, (isSelected || isEditing) && createElement(ReusableBlockEditPanel, {
    isEditing: isEditing,
    title: reusableBlock.title,
    isSaving: isSaving,
    isEditDisabled: !canUserUpdate,
    onEdit: function onEdit() {
      return setIsEditing(true);
    },
    onChangeTitle: function onChangeTitle(title) {
      return editEntityRecord.apply(void 0, recordArgs.concat([{
        title: title
      }]));
    },
    onSave: function onSave() {
      save();
      setIsEditing(false);
    }
  }), element));
}
//# sourceMappingURL=edit.js.map